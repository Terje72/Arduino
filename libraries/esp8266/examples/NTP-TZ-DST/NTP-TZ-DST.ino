/*
  NTP-TZ-DST (v2)
  NetWork Time Protocol - Time Zone - Daylight Saving Time

  This example shows:
  - how to read and set time
  - how to set timezone per country/city
  - how is local time automatically handled per official timezone definitions

  This example code is in the public domain.
*/


#ifndef STASSID
#define STASSID "your-ssid"
#define STAPSK  "your-password"
#endif

// initial time (possibly given by an external RTC)
#define RTC_UTC_TEST 1510592825 // 1510592825 = Monday 13 November 2017 17:07:05 UTC


// This database is autogenerated from IANA timezone database
//    https://www.iana.org/time-zones
// and can be updated on demand in this repository
#include <TZ.h>

// "TZ_" macros follow DST change across seasons without source code change
// check for your nearest city in TZ.h

// select espressif headquarter TZ
#define MYTZ TZ_Asia_Shanghai

// example for "Not Only Whole Hours" timezones:
// Kolkata/Calcutta is shifted by 30mn
//#define MYTZ TZ_Asia_Kolkata

// example to watch automatic local time time adjustment on Summer/Winter change
// (exactly 182 days (~6 month) are regularly added or substracted in the example)
//#define MYTZ TZ_Europe_Paris

////////////////////////////////////////////////////////

#include <ESP8266WiFi.h>
#include <coredecls.h>                  // settimeofday_cb()
#include <Schedule.h>
#include <PolledTimeout.h>

#include <time.h>                       // time() ctime()
#include <sys/time.h>                   // struct timeval

#include <lwip/apps/sntp.h>

// for testing purpose:
extern "C" int clock_gettime(clockid_t unused, struct timespec *tp);

////////////////////////////////////////////////////////

timeval tv;
timespec tp;
time_t now;
uint32_t now_ms, now_us;

bool time_is_set = false;
esp8266::polledTimeout::periodicMs showTime(3200);
bool next_change_is_future = true;
esp8266::polledTimeout::periodicMs add_6months_now(1 << 30);

unsigned long testcbms;

void time_is_set_scheduled() {
  // everything is allowed in this function
  Serial.printf("\n----------> scheduled CB: settimeofday() has been called %ldms ago <----------\n"
                "sleeping 2s\n\n",
                millis() - testcbms);
  delay(2000);
}

void time_is_set_callback() {
  // like in an ISR
  // it is not allowed to call "heavy" core API
  // like yield()/delay()/print()/network/...

  time_is_set = true;

  testcbms = millis();
  // call time_is_set_scheduled() at next loop():
  schedule_function(time_is_set_scheduled);
}

// optional: change SNTP startup delay (default: 0)
// a weak function is already defined and returns 0 (violating RFcs)
// user can redefine it:
//uint32_t sntp_startup_delay_func_MS_not_less_than_60000 ()
//{
//    return 60000; // 10s (or (random() % 5000))
//}

void setup() {
  Serial.begin(115200);
  Serial.println("\nStarting...\n");

  // setup RTC time
  // it will be used until NTP server will send us real current time
  time_t rtc = RTC_UTC_TEST;
  timeval tv = { rtc, 0 };
  timezone tz = { 0, 0 };
  settimeofday(&tv, &tz);

  // install callback - called when settimeofday is called (by SNTP or us)
  // once enabled (by DHCP), SNTP is updated every hour
  settimeofday_cb(time_is_set_callback);

  // NTP servers may be overriden by your DHCP server for a more local one
  // (see below)
  configTime(MYTZ, "pool.ntp.org");

  // optional: change SNTP update delay (default: 1 hour = SNTP_UPDATE_DELAY_DEFAULT)
  //sntp_update_delay_MS_not_less_than_15000 = 600000; // 10mn / 600s / 600'000ms
  // optional: disable obtaining SNTP servers from DHCP
  //sntp_servermode_dhcp(0); // 0: disable (enabled by default)

  // start network
  WiFi.persistent(false);
  WiFi.mode(WIFI_STA);
  WiFi.begin(STASSID, STAPSK);

  // don't wait for network, observe time changing
  // when NTP timestamp is received
}

#define PTM(w) \
  Serial.print(" " #w "="); \
  Serial.print(tm->tm_##w);

void printTm(const char* what, const tm* tm) {
  Serial.print(what);
  PTM(isdst); PTM(yday); PTM(wday);
  PTM(year);  PTM(mon);  PTM(mday);
  PTM(hour);  PTM(min);  PTM(sec);
}

void loop() {

  if (time_is_set) {
    Serial.printf("\n----------> loop: settimeofday() has been called %ldms ago ! <----------\n\n", millis() - testcbms);
    time_is_set = false;
    add_6months_now.reset(20000);
  }

  if (showTime) {
    gettimeofday(&tv, nullptr);
    clock_gettime(0, &tp);
    now = time(nullptr);
    now_ms = millis();
    now_us = micros();

    // for demo purpose, switch 6 months back and forth
    if (add_6months_now) {
      tv.tv_sec += (next_change_is_future ? -1 : 1) * (60 * 60 * 24 * 364 / 2);
      settimeofday(&tv, nullptr);
      Serial.printf("\n"
                    "-- time machine: artificially moving 6 months %s\n"
                    "-- observe local time change according to selected TZ's DST rules\n"
                    "-- (and without assistance from sketch)\n"
                    "\n",
                    next_change_is_future ? "forward (future)" : "backward (to now)");
      next_change_is_future = !next_change_is_future;
      return;
    }

    printTm("localtime:", localtime(&now));
    Serial.println();
    printTm("gmtime:   ", gmtime(&now));
    Serial.println();

    // time from boot
    Serial.print("clock:     ");
    Serial.print((uint32_t)tp.tv_sec);
    Serial.print("s / ");
    Serial.print((uint32_t)tp.tv_nsec);
    Serial.println("ns");

    // time from boot
    Serial.print("millis:    ");
    Serial.println(now_ms);
    Serial.print("micros:    ");
    Serial.println(now_us);

    // EPOCH+tz+dst
    Serial.print("gtod:      ");
    Serial.print((uint32_t)tv.tv_sec);
    Serial.print("s / ");
    Serial.print((uint32_t)tv.tv_usec);
    Serial.println("us");

    // EPOCH+tz+dst
    Serial.print("time:      ");
    Serial.println((uint32_t)now);

    // timezone and demo in the future
    Serial.printf("timezone:  %s\n", MYTZ);
    Serial.printf("in future: %s\n", next_change_is_future ? "no" : "6 months");

    // human readable
    Serial.print("ctime:     ");
    Serial.print(ctime(&now));

    Serial.println();
  }
}
